#!/usr/bin/env python3
"""Order-flow based toy backtest.

The script consumes the CSV generated by orderflow_demo.py (or any file with
matching columns) and evaluates a simple rule-set:

    - Long when top-of-book imbalance is positive, recent Delta accumulates,
      and the CVD slope points higher.
    - Short on the symmetric condition.
    - Exit via fixed take-profit / stop-loss or on the opposite signal.

Outputs (written under ./output by default):
    - trades.csv: detailed trade log.
    - backtest_summary.csv: aggregate performance statistics.
    - equity_curve.png: mark-to-market equity progression.
"""

from __future__ import annotations

import argparse
import json
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import List

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd


plt.style.use("ggplot")


@dataclass
class StrategyConfig:
    lookback: int = 30
    long_imbalance: float = 0.20
    short_imbalance: float = -0.20
    delta_threshold: float = 15.0
    take_profit: float = 0.0010  # 10 bps
    stop_loss: float = 0.0008  # 8 bps
    reverse_on_signal: bool = True
    initial_capital: float = 0.0  # PnL is in quote currency units (per 1 contract)


@dataclass
class Trade:
    direction: int
    entry_time: pd.Timestamp
    exit_time: pd.Timestamp
    entry_price: float
    exit_price: float
    pnl: float
    bars_held: int

    def to_dict(self) -> dict:
        data = asdict(self)
        data["direction"] = "LONG" if self.direction > 0 else "SHORT"
        return data


def ensure_output_dir(path: Path) -> Path:
    path.mkdir(parents=True, exist_ok=True)
    return path


def compute_features(df: pd.DataFrame, cfg: StrategyConfig) -> pd.DataFrame:
    df = df.copy()
    df["delta_sum"] = df["delta"].rolling(window=cfg.lookback, min_periods=1).sum()
    df["cvd_slope"] = (
        df["cvd"].diff().rolling(window=cfg.lookback, min_periods=1).mean()
    )
    df["long_signal"] = (
        (df["ob_imbalance"] > cfg.long_imbalance)
        & (df["delta_sum"] > cfg.delta_threshold)
        & (df["cvd_slope"] > 0)
    )
    df["short_signal"] = (
        (df["ob_imbalance"] < cfg.short_imbalance)
        & (df["delta_sum"] < -cfg.delta_threshold)
        & (df["cvd_slope"] < 0)
    )
    return df


def max_drawdown(equity: np.ndarray) -> float:
    running_max = np.maximum.accumulate(equity)
    drawdowns = running_max - equity
    return float(np.max(drawdowns))


def sharpe_ratio(returns: np.ndarray) -> float:
    if returns.size == 0:
        return float("nan")
    if np.allclose(returns.std(ddof=1), 0):
        return 0.0
    return float(np.sqrt(252 * 24 * 60 * 60) * returns.mean() / returns.std(ddof=1))


def backtest(df: pd.DataFrame, cfg: StrategyConfig) -> tuple[List[Trade], np.ndarray]:
    trades: List[Trade] = []
    equity = [cfg.initial_capital]
    trade_returns: List[float] = []

    position = 0
    entry_price = None
    entry_time = None
    target = None
    stop = None

    for i, (ts, row) in enumerate(df.iterrows()):
        price = row["mid"]
        long_sig, short_sig = row["long_signal"], row["short_signal"]

        if position == 0:
            if long_sig:
                position = 1
                entry_price = price
                entry_time = ts
                target = entry_price * (1 + cfg.take_profit)
                stop = entry_price * (1 - cfg.stop_loss)
                continue
            if short_sig:
                position = -1
                entry_price = price
                entry_time = ts
                target = entry_price * (1 - cfg.take_profit)
                stop = entry_price * (1 + cfg.stop_loss)
                continue

        else:
            exit_reason = None
            exit_price = price

            if position > 0:
                if price >= target:
                    exit_reason = "tp"
                    exit_price = target
                elif price <= stop:
                    exit_reason = "sl"
                    exit_price = stop
                elif short_sig and cfg.reverse_on_signal:
                    exit_reason = "flip"
                elif short_sig:
                    exit_reason = "opposite"
            else:  # short
                if price <= target:
                    exit_reason = "tp"
                    exit_price = target
                elif price >= stop:
                    exit_reason = "sl"
                    exit_price = stop
                elif long_sig and cfg.reverse_on_signal:
                    exit_reason = "flip"
                elif long_sig:
                    exit_reason = "opposite"

            if exit_reason is not None:
                pnl = (exit_price - entry_price) * position
                bars_held = i - df.index.get_loc(entry_time)
                trades.append(
                    Trade(
                        direction=position,
                        entry_time=entry_time,
                        exit_time=ts,
                        entry_price=entry_price,
                        exit_price=exit_price,
                        pnl=pnl,
                        bars_held=bars_held,
                    )
                )
                equity.append(equity[-1] + pnl)
                trade_returns.append(pnl / abs(entry_price))

                # Flip if required
                if exit_reason == "flip":
                    position *= -1
                    entry_price = price
                    entry_time = ts
                    if position > 0:
                        target = entry_price * (1 + cfg.take_profit)
                        stop = entry_price * (1 - cfg.stop_loss)
                    else:
                        target = entry_price * (1 - cfg.take_profit)
                        stop = entry_price * (1 + cfg.stop_loss)
                    continue

                position = 0
                entry_price = entry_time = target = stop = None

    return trades, np.array(equity), np.array(trade_returns)


def summarise(trades: List[Trade], equity: np.ndarray, trade_returns: np.ndarray) -> dict:
    if not trades:
        return {
            "total_trades": 0,
            "win_rate": float("nan"),
            "avg_trade": 0.0,
            "cumulative_pnl": 0.0,
            "max_drawdown": 0.0,
            "sharpe": float("nan"),
            "profit_factor": float("nan"),
        }

    pnl = np.array([t.pnl for t in trades])
    wins = pnl[pnl > 0].sum()
    losses = -pnl[pnl < 0].sum()
    profit_factor = wins / losses if losses > 0 else float("inf")

    return {
        "total_trades": int(len(trades)),
        "win_rate": float((pnl > 0).mean()),
        "avg_trade": float(pnl.mean()),
        "cumulative_pnl": float(pnl.sum()),
        "max_drawdown": max_drawdown(equity),
        "sharpe": sharpe_ratio(trade_returns),
        "profit_factor": profit_factor,
    }


def plot_equity_curve(equity: np.ndarray, df: pd.DataFrame, output_path: Path) -> None:
    if equity.size == 0:
        return

    # Duplicate the last timestamp to align lengths (equity includes initial capital).
    time_index = [df.index[0]] + list(df.index[: len(equity) - 1])

    fig, ax = plt.subplots(figsize=(12, 5))
    ax.plot(time_index, equity, color="#1976d2", linewidth=1.6)
    ax.set_title("Equity Curve (per-contract PnL)")
    ax.set_ylabel("PnL")
    ax.set_xlabel("Timestamp")
    fig.tight_layout()
    fig.savefig(output_path, dpi=150)
    plt.close(fig)


def main() -> None:
    parser = argparse.ArgumentParser(description="Order-flow toy backtest.")
    parser.add_argument(
        "--input",
        type=Path,
        default=Path("output/orderflow_demo.csv"),
        help="CSV file with columns: timestamp, mid, delta, cvd, ob_imbalance.",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path("output"),
        help="Directory for backtest artifacts.",
    )
    parser.add_argument("--lookback", type=int, default=None)
    parser.add_argument("--long-imbalance", type=float, default=None)
    parser.add_argument("--short-imbalance", type=float, default=None)
    parser.add_argument("--delta-threshold", type=float, default=None)
    parser.add_argument("--take-profit", type=float, default=None)
    parser.add_argument("--stop-loss", type=float, default=None)
    parser.add_argument("--no-reverse", action="store_true", help="Disable flips.")
    args = parser.parse_args()

    cfg = StrategyConfig()
    if args.lookback:
        cfg.lookback = max(1, args.lookback)
    if args.long_imbalance is not None:
        cfg.long_imbalance = args.long_imbalance
    if args.short_imbalance is not None:
        cfg.short_imbalance = args.short_imbalance
    if args.delta_threshold is not None:
        cfg.delta_threshold = args.delta_threshold
    if args.take_profit is not None:
        cfg.take_profit = args.take_profit
    if args.stop_loss is not None:
        cfg.stop_loss = args.stop_loss
    if args.no_reverse:
        cfg.reverse_on_signal = False

    output_dir = ensure_output_dir(args.output_dir)
    df = pd.read_csv(args.input, parse_dates=["timestamp"])
    df = df.set_index("timestamp")

    feature_df = compute_features(df, cfg)
    trades, equity, trade_returns = backtest(feature_df, cfg)
    stats = summarise(trades, equity, trade_returns)

    trades_path = output_dir / "trades.csv"
    summary_path = output_dir / "backtest_summary.csv"
    equity_path = output_dir / "equity_curve.png"
    json_path = output_dir / "backtest_config.json"

    pd.DataFrame([t.to_dict() for t in trades]).to_csv(trades_path, index=False)
    pd.DataFrame([stats]).to_csv(summary_path, index=False)
    plot_equity_curve(equity, feature_df, equity_path)
    with open(json_path, "w", encoding="utf-8") as f:
        json.dump({"strategy_config": asdict(cfg), "stats": stats}, f, indent=2)

    print(f"Generated trade log -> {trades_path.as_posix()}")
    print(f"Summary metrics     -> {summary_path.as_posix()}")
    print(f"Equity curve plot   -> {equity_path.as_posix()}")
    print(f"Configuration dump  -> {json_path.as_posix()}")


if __name__ == "__main__":
    main()
